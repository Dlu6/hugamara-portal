// controllers/outboundRouteController.js
import sequelize, { Op } from "../config/sequelize.js";
import {
  OutboundRoute,
  OutboundRouteApplication,
} from "../models/outboundRouteModel.js";
import VoiceExtension from "../models/voiceExtensionModel.js";
// import { updateDialplanConfig } from "../utils/asteriskConfigWriter.js";

// Sanitize application payloads to ensure consistent Dial expressions
const sanitizeOutboundApplications = (applications = []) => {
  return (applications || []).map((app) => {
    if (app && app.type === "OutboundDial") {
      const settings = { ...(app.settings || {}) };
      let exten =
        typeof settings.exten === "string" ? settings.exten.trim() : "";

      // Normalize to ${EXTEN} when empty or when caret artifacts were sent
      if (!exten || exten === "^" || exten === "âˆ§") {
        exten = "${EXTEN}";
      }

      // Remove any accidental escaping like \${EXTEN}
      if (/^\\\$\{EXTEN\}$/.test(exten)) {
        exten = "${EXTEN}";
      }

      // Ensure required fields exist
      settings.exten = exten;
      settings.prefix = settings.prefix || "";
      settings.trunkId = settings.trunkId || settings.trunk || "";

      return { ...app, settings };
    }
    return app;
  });
};

// Helper function to generate voice extensions from applications
const generateExtensionsFromApp = (app, routeId, route, appIndex) => {
  const priority = 3 + appIndex; // Change priority to start at 3 and increment by 1
  const extension = {
    context: route.context,
    extension: route.phoneNumber,
    priority: priority,
    type: "outbound",
    outboundRouteId: routeId,
    isGenerated: true,
    generatedByAppId: app.id,
  };

  if (app.type === "OutboundDial") {
    return {
      ...extension,
      app: "Dial",
      appdata: `PJSIP/${app.settings.prefix || ""}\${EXTEN}@${
        app.settings.trunkId
      }`,
      tag: app.settings.tag || "",
      description: "Generated by OutboundDial application",
    };
  } else if (app.type === "Custom") {
    return {
      ...extension,
      app: app.settings.applicationName,
      appdata: app.settings.arguments,
      description: "Generated by Custom application",
    };
  }

  return null;
};

export const createOutboundRoute = async (req, res) => {
  const transaction = await sequelize.transaction();

  try {
    const routeData = req.body;
    // Sanitize application payload for continuity (${EXTEN})
    const sanitizedApplications = sanitizeOutboundApplications(
      routeData.applications || []
    );
    const { voiceExtensions, ...mainRouteData } = routeData;

    // Save the route to the database
    const route = await OutboundRoute.create(mainRouteData, { transaction });

    // Create default CDR extensions
    const defaultExtensions = [
      {
        context: mainRouteData.context,
        extension: mainRouteData.phoneNumber,
        priority: 1,
        app: "Set",
        appdata: "CDR(type)=outbound",
        type: "outbound",
        outboundRouteId: route.id,
        isGenerated: true,
        description: "Set CDR type",
      },
      {
        context: mainRouteData.context,
        extension: mainRouteData.phoneNumber,
        priority: 2,
        app: "Set",
        appdata: "CDR(destination)=${EXTEN}",
        type: "outbound",
        outboundRouteId: route.id,
        isGenerated: true,
        description: "Set CDR destination",
      },
      {
        context: mainRouteData.context,
        extension: "h",
        priority: 1,
        app: "Hangup",
        type: "outbound",
        outboundRouteId: route.id,
        isGenerated: true,
        description: "Hangup handler",
      },
    ];

    await VoiceExtension.bulkCreate(defaultExtensions, { transaction });

    // Create manual voice extensions if provided (with adjusted priorities)
    if (voiceExtensions && voiceExtensions.length > 0) {
      await VoiceExtension.bulkCreate(
        voiceExtensions.map((ve, index) => ({
          ...ve,
          outboundRouteId: route.id,
          isGenerated: false,
          priority: index + 3, // Start after our default extensions
        })),
        { transaction }
      );
    }

    // Create applications and their generated voice extensions
    if (sanitizedApplications && sanitizedApplications.length > 0) {
      // Create the applications
      const createdApps = await OutboundRouteApplication.bulkCreate(
        sanitizedApplications.map((app, index) => ({
          outboundRouteId: route.id,
          type: app.type,
          priority: index + 1,
          settings: app.settings,
        })),
        { transaction, returning: true }
      );

      // Generate and create voice extensions from applications
      const generatedExtensions = [];
      createdApps.forEach((app, index) => {
        const extension = generateExtensionsFromApp(
          app,
          route.id,
          route,
          index
        );
        if (extension) {
          generatedExtensions.push(extension);
        }
      });

      if (generatedExtensions.length > 0) {
        await VoiceExtension.bulkCreate(generatedExtensions, { transaction });
      }
    }

    await transaction.commit();

    // Fetch the complete route with all associations
    const createdRoute = await OutboundRoute.findByPk(route.id, {
      include: [
        {
          model: VoiceExtension,
          as: "voiceExtensions",
          where: { isGenerated: false },
          required: false,
        },
        {
          model: OutboundRouteApplication,
          as: "applications",
        },
      ],
    });

    res.status(201).json({
      success: true,
      message: "Outbound route created successfully",
      route: createdRoute,
    });
  } catch (error) {
    await transaction.rollback();
    console.error("Error creating outbound route:", error);
    res.status(500).json({
      success: false,
      message: error.message || "Failed to create outbound route",
    });
  }
};

export const getOutboundRoutes = async (req, res) => {
  try {
    const routes = await OutboundRoute.findAll({
      order: [["id", "ASC"]],
      include: [
        {
          model: VoiceExtension,
          as: "voiceExtensions",
          where: { isGenerated: false }, // Only get manual extensions
          required: false,
        },
        {
          model: OutboundRouteApplication,
          as: "applications",
          order: [["priority", "ASC"]],
        },
      ],
    });

    res.status(200).json({
      success: true,
      routes,
    });
  } catch (error) {
    console.error("Error fetching outbound routes:", error);
    res.status(500).json({
      success: false,
      message: "Failed to fetch outbound routes",
    });
  }
};

export const getOutboundRouteById = async (req, res) => {
  try {
    const route = await OutboundRoute.findByPk(req.params.routeId, {
      include: [
        {
          model: VoiceExtension,
          as: "voiceExtensions",
          required: false,
          order: [["priority", "ASC"]], // Order by priority
        },
        {
          model: OutboundRouteApplication,
          as: "applications",
          order: [["priority", "ASC"]],
        },
      ],
    });

    if (!route) {
      return res.status(404).json({
        success: false,
        message: "Outbound route not found",
      });
    }

    // Separate manual and generated extensions
    const manualExtensions = route.voiceExtensions.filter(
      (ext) => !ext.isGenerated
    );
    const generatedExtensions = route.voiceExtensions.filter(
      (ext) => ext.isGenerated
    );

    // Create a new response object with separated extensions
    const responseRoute = {
      ...route.toJSON(),
      voiceExtensions: manualExtensions, // Keep only manual extensions in the main array
      generatedExtensions: generatedExtensions, // Add generated extensions separately
    };

    res.status(200).json({
      success: true,
      route: responseRoute,
    });
  } catch (error) {
    console.error("Error fetching outbound route:", error);
    res.status(500).json({
      success: false,
      message: "Failed to fetch outbound route",
    });
  }
};

export const updateOutboundRoute = async (req, res) => {
  const transaction = await sequelize.transaction();

  try {
    const routeId = req.params.routeId;
    const { applications, voiceExtensions, ...mainRouteData } = req.body;

    const route = await OutboundRoute.findByPk(routeId);
    if (!route) {
      await transaction.rollback();
      return res.status(404).json({
        success: false,
        message: "Outbound route not found",
      });
    }

    // Update route definition
    await route.update(mainRouteData, { transaction });

    // Update manual voice extensions
    if (voiceExtensions !== undefined) {
      // Delete existing manual extensions
      await VoiceExtension.destroy({
        where: { outboundRouteId: routeId, isGenerated: false },
        transaction,
      });

      // Create new manual extensions
      if (voiceExtensions && voiceExtensions.length > 0) {
        await VoiceExtension.bulkCreate(
          voiceExtensions.map((ext) => ({
            ...ext,
            outboundRouteId: routeId,
            type: "outbound",
            isGenerated: false,
          })),
          { transaction }
        );
      }
    }

    // Update applications and their generated extensions
    if (applications !== undefined) {
      // Delete only app-generated extensions, preserving default CDR extensions
      await VoiceExtension.destroy({
        where: {
          outboundRouteId: routeId,
          isGenerated: true,
          generatedByAppId: {
            [Op.not]: null, // Only delete extensions generated by applications
          },
        },
        transaction,
      });

      await OutboundRouteApplication.destroy({
        where: { outboundRouteId: routeId },
        transaction,
      });

      if (applications && applications.length > 0) {
        const sanitizedApplications =
          sanitizeOutboundApplications(applications);
        // Create new applications
        const createdApps = await OutboundRouteApplication.bulkCreate(
          sanitizedApplications.map((app, index) => ({
            outboundRouteId: routeId,
            type: app.type,
            priority: index + 1,
            settings: app.settings,
          })),
          { transaction, returning: true }
        );

        // Generate and create voice extensions from applications
        const generatedExtensions = [];
        createdApps.forEach((app, index) => {
          const extension = generateExtensionsFromApp(
            app,
            routeId,
            route,
            index
          );
          if (extension) {
            generatedExtensions.push(extension);
          }
        });

        if (generatedExtensions.length > 0) {
          await VoiceExtension.bulkCreate(generatedExtensions, { transaction });
        }
      }
    }

    await transaction.commit();

    // Fetch updated route with all associations
    const updatedRoute = await OutboundRoute.findByPk(routeId, {
      include: [
        {
          model: VoiceExtension,
          as: "voiceExtensions",
          required: false,
          order: [["priority", "ASC"]], // Order by priority
        },
        {
          model: OutboundRouteApplication,
          as: "applications",
          order: [["priority", "ASC"]],
        },
      ],
    });

    // Separate manual and generated extensions for the response
    const manualExtensions = updatedRoute.voiceExtensions.filter(
      (ext) => !ext.isGenerated
    );
    const generatedExtensions = updatedRoute.voiceExtensions.filter(
      (ext) => ext.isGenerated
    );

    const responseRoute = {
      ...updatedRoute.toJSON(),
      voiceExtensions: manualExtensions,
      generatedExtensions: generatedExtensions,
    };

    res.status(200).json({
      success: true,
      message: "Outbound route updated successfully",
      route: responseRoute,
    });
  } catch (error) {
    await transaction.rollback();
    console.error("Error updating outbound route:", error);
    res.status(500).json({
      success: false,
      message: error.message || "Failed to update outbound route",
    });
  }
};

export const deleteOutboundRoute = async (req, res) => {
  const transaction = await sequelize.transaction();

  try {
    const routeId = req.params.routeId;
    const route = await OutboundRoute.findByPk(routeId);

    if (!route) {
      await transaction.rollback();
      return res.status(404).json({
        success: false,
        message: "Outbound route not found",
      });
    }

    // First explicitly delete all voice extensions associated with this route
    // This includes both manually created and generated extensions
    await VoiceExtension.destroy({
      where: { outboundRouteId: routeId },
      transaction,
    });

    // Delete all applications for this route
    await OutboundRouteApplication.destroy({
      where: { outboundRouteId: routeId },
      transaction,
    });

    // Finally delete the route itself
    await route.destroy({ transaction });

    await transaction.commit();

    res.status(200).json({
      success: true,
      message: "Outbound route deleted successfully",
    });
  } catch (error) {
    await transaction.rollback();
    console.error("Error deleting outbound route:", error);
    res.status(500).json({
      success: false,
      message: error.message || "Failed to delete outbound route",
    });
  }
};
